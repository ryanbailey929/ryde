//author Ryan Bailey

#include <iostream>
#include <string>
#include <filesystem>
#include <algorithm>
#include <regex>
#include <fstream>

int main(int argc, char** argv)
{
    namespace fs = std::filesystem;

    switch(argc)
    {
    case 1:
        std::cerr << "Error: No command line arguments passed in.\n";
        return -1;
    case 2:
        break;
    default:
        std::cerr << "Error: Too many command line arguments passed in.\n";
        return -1;
    }

    std::string shader_file {(argv[1])};
    std::string pattern {R"(src/shaders/glsl/[A-Za-z0-9_]+\.((vert)|(frag)))"};

    //check to see that the shader file matches the regex pattern
    //I'm using regex_match to test that the entire string fits the pattern, not just
    //a substring
    if(!regex_match(shader_file, std::regex {pattern}))
    {
        std::cerr << "File given doesn't match the pattern "
                     "src/shaders/glsl/file_name.vert "
                     "OR shaders/glsl/file_name.frag, where file_name can be any "
                     "sequence of characters matching the regex patten:\n"
                     "[A-Za-z0-9_]+\n";
        return -1;
    }

    if(!fs::exists(shader_file))
    {
        std::cerr << "Error: The shader file passed in does not exist.\nPath given: "
                  << shader_file << '\n';
        return -1;
    }

    //extract name of glsl file (and then discard the .vert/.frag).
    std::string shader_filename {(fs::path(shader_file)).filename()};
    //but remember the shader type before discarding the file extension
    //(using regex_search here as ".vert" is a substring of shader_filename)
    bool is_vertex_shader {(std::regex_search(shader_filename, std::regex {".vert"}))};
    shader_filename = shader_filename.substr(0, shader_filename.find("."));

    //if shader_filename is example_filename, then shader_filename_upper
    //should be EXAMPLEFILENAME
    std::string shader_filename_upper {shader_filename};
    shader_filename_upper.erase(std::remove(shader_filename_upper.begin(),
                                            shader_filename_upper.end(), '_'),
                                shader_filename_upper.end());
    std::transform(shader_filename_upper.begin(), shader_filename_upper.end(),
                   shader_filename_upper.begin(),
                   [] (unsigned char c) {return std::toupper(c);});
    std::string header_guards_identifier
        {(is_vertex_shader) ? ("RYDE_SHADERS_HEADERS_" + shader_filename_upper +
                               "_VERTEX_HPP")
                            : ("RYDE_SHADERS_HEADERS_" + shader_filename_upper +
                               "_FRAGMENT_HPP")};
    std::string shader_header_filename
        {(is_vertex_shader) ? (shader_filename + "_vertex_shader.hpp")
                            : (shader_filename + "_fragment_shader.hpp")};
    //the following turns example_filename (from shader_filename) into ExampleFilename
    //(for inner_namespace_identifier)
    bool capitalise_next_letter = true;
    std::string inner_namespace_identifier {};
    for(std::string::iterator it {shader_filename.begin()}; it != shader_filename.end();
        ++it)
    {
        if(regex_match(std::string {*it},
                       std::regex("[A-Za-z]")) && capitalise_next_letter)
        {
            inner_namespace_identifier.push_back(std::toupper((unsigned char) (*it)));
            capitalise_next_letter = false;
        }
        else if ((*it) == '_')
            capitalise_next_letter = true;
        else
            inner_namespace_identifier.push_back(*it);
    }
    std::string shader_header_file {"src/shaders/headers/" + shader_header_filename};
    std::string shader_header_file_contents
    {
        "//auto generated by bin/create_shader_header\n"
        "//the glsl file used to create this file is " + shader_file + "\n"
        "//(the above paths are relative to the root of the ryde git repository)\n\n"
        "#ifndef " + header_guards_identifier + "\n"
        "#define " + header_guards_identifier + "\n\n"
        "#include <string>\n\n"
        "namespace Shaders::" + inner_namespace_identifier + "\n{\n"
        "    inline static std::string " +
        ((is_vertex_shader) ? "vertex_shader_source\n" : "fragment_shader_source\n") +
        "    {\n"
    };

    //extract and encapsulate the contents of the glsl file
    std::ifstream shader_file_ifstream;
    shader_file_ifstream.open(shader_file);
    std::string line {};
    while(std::getline(shader_file_ifstream, line))
    {
        if(line.length() == 0) //no need to add empty lines
            continue;
        ((shader_header_file_contents += "        \"") += line) += "\\n\"\n";
    }
    shader_header_file_contents += "    };\n}\n\n#endif\n";
    shader_file_ifstream.close();

    //write the shader header file
    std::ofstream shader_header_file_ofstream;
    shader_header_file_ofstream.open(shader_header_file);
    shader_header_file_ofstream << shader_header_file_contents;
    shader_header_file_ofstream.close();

    return 0;
}
